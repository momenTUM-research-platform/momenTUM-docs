# Components

 ## Atoms
 The frontend uses an abstraction layer when it comes to storing and retrieving study data:

 All of the several types of content for the study, like modules, questions, sections and the properties object, are abstracted away into a so-called Atom. Its type definition is:

 ``` Typescript
// As defined in types.d.ts
declare interface Atom<T> {
    parent: string | null;
    subNodes: string[] | null;
    type: AtomVariants;
    childType: AtomVariants | null;
    content: T;
    title: string; // Displayed on node
    actions: Actions[];
    hidden: boolean;
  }
```
 Next to the actual content that a user provides, such as the question text, which is stored in the `content` field,
 an Atom also stores information about its position in the study graph, such as its parent and children, and its type.

 The actions field is used to store the actions that are available for the user to perform on the node.
 For example, a section node has the actions `add`, `delete`, `earlier`, and `later`.
 These actions are stored as an array of strings, which are then mapped to the corresponding action handler.
 Then, buttons are rendered on each node, which call the corresponding action handler when clicked.

 Each Atom has a unique ID, automatically generated by `nanoid()` and is stored in a hashmap.
 This benefits performance, as it allows for O(1) access to the atoms, instead of searching through all nodes sequentially.
 The atoms are stored in a global state object, which is managed by Zustand.
 This allows for easy access to the atoms from anywhere in the application, just by using the `useStore` hook.

 ``` Typescript
 import { useStore } from "./state";
 const {atoms} = useStore();
 ```
 ## Reacting to change
 Whenever a user clicks on a node in the study graph, the corresponding Atom is retrieved from the global state object
 and a form is rendered based on the content of the Atom. The corresponding form is generated by retreiving the JSON schema for the Atom's type from the `schema` folder.
 Whenever the user changes the content of the form, the corresponding Atom is updated in the global state object.

 ``` Typescript
 setAtom: (id, content) =>
    set(
        produce((state: State) => {
          const atom = state.atoms.get(id)!;
          atom.content = content;
          ... // Some details omitted
        })
      ),

```

 The updating is done using the `produce` function from the `immer` library.

 ## Graph
 Whenever the number of atoms changes, such as when a new atom is added or an atom is deleted, the study graph is re-calculated.
 This is handled by the `useGraph` hook in the `Graph.tsx` file.

 ``` Typescript
 function useGraph(): [Node[], Edge[]] {
  let { atoms, selectedNode, direction, forceRedraw } = useStore();
  
 const visibleAtoms = useMemo(
    () => hideAtoms(selectedNode || "study", atoms),
    [selectedNode, atoms.size, forceRedraw]
  );

  let [nodes, edges] = useMemo(
    () => calcGraphFromAtoms(visibleAtoms),
    [visibleAtoms, direction]);

  [nodes, edges] = useMemo(
    () => alignNodes(nodes, edges, direction),
    [nodes, edges, direction, visibleAtoms]
  );

  return [nodes, edges];
}
 ```

 Ordinarily, the Graph component would be rerendered every time one of the deconstructed items of the `useStore()` hook changes.
 However, it would be unnecessary to do this on every key-press when the user types something into a form.
 Therefore, this hooks makes use of `useMemo`, to only re-run a callback function when one of the items in the dependency array changes.

 First, the `hideAtoms()` function is called, which returns a new hashmap of atoms, where all atoms that are not supposed to be visible have their `hidden` field set to `true`.
 This is used to hide atoms that are not part of the currently selected branch of the study graph. For example, when the user edits a question of one module, questions of other modules are not shown.

 Next, the `calcGraphFromAtoms()` function is called, which returns an array of nodes and edges by iterating through the atoms hashmap and connecting them according to the `parent` and `subnodes` fields.

 Finally, the `alignNodes()` function is called, which aligns the nodes in the graph according to the `direction` field of the global state object.
 The layout is performed by the `dagre` library, which creates a neat arrangement of the nodes and edges.

 The final graph is then handed to ReactFlow, which displays it on the screen.


 ## Creating the actual study

 Once the user is done editing the study, they have several options to proceed.
 Most of them are included in the `Actions` dropdown menu, and defined in the `actions.ts` file.

 As an expample, let's go through the Upload-Action.

 When a user clicks on the Upload button, a modal is rendered, which guides the user through the process of uploading the study to the server.

 Within the Upload.tsx component, the progress of the upload is tracked using a `useEffect` hook, which has several steps defined in it.

 ``` Typescript
  const [step, setStep] = useState(0);
  const { atoms, setModal, setPermalink } = useStore();
  const study: Study = useMemo(() => constructStudy(atoms), []);
  useEffect(() => {
    if (step < 0 || step > 3) return;
    const actions = [
      //  Authenticate
      () =>
        new Promise((resolve, reject) => {
          resolve(null);
        }), // Not yet implemented
      // Validate
      () =>
        new Promise((resolve, reject) =>
          validateStudy(study) ? resolve(null) : reject("Study is invalid")
        ),
      // Upload
      () => upload(study),
      // Finished
      () => new Promise((resolve, reject) => resolve(null)),
    ];
    actions[step]()
      .then((result) => {
        if (step === 2) setPermalink(result as string);
        setStep(step + 1);
      })
      .catch((e) => toast.error(e));
  }, [step]);
 ```

 Basically, we go through the list of actions and execute them one after another, always waiting for
 the previous action to finish before starting the next one by awaiting the promise to return.

 The first action is to authenticate the user. This is not yet implemented, so it just returns a resolved promise.
 Then, we build the study from the atoms (which is not unlike building the graph earlier) and validate it.
 If the validation fails, we show an error message and stop the upload process.

 If the validation succeeds, we upload the study to the server. This is done by calling the `upload()` function, which is defined in the `upload.ts` file.
 The API then validates the study again and saves it to the database and returns a permanent ID for this specific version of the study.

 We then take this ID and create two QR-Codes, one for this exact version of the study, and one which always points to the latest version of the study (by using the user-specified `study_id`).

 Finally, we show the user the QR-Codes and a link to the study, which they can share with others.
